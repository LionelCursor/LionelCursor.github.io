<!DOCTYPE html><html lang="zh"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="在年轻的时候，或修道还没有成功的时候，或者倒霉得没有办法的时候，就要“沉潜”在深水里，动都不要动。"><title>Android线程通信模型(Handler and Loop) | Damon Lei</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android线程通信模型(Handler and Loop)</h1><a id="logo" href="/.">Damon Lei</a><p class="description">在年轻的时候，或修道还没有成功的时候，或者倒霉得没有办法的时候，就要“沉潜”在深水里，动都不要动。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Inicio</i></a><a href="/archives/"><i class="fa fa-archive"> Archivo</i></a><a href="/about/"><i class="fa fa-user"> Acerca de</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android线程通信模型(Handler and Loop)</h1><div class="post-meta">Mar 30, 2015<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>今天在看IntentService的时候，发现自己对于线程通信模型并不十分了解。于是把Handler and Loop模型重新学了一遍。总结一下加深记忆。</p>
<p>##模型分析<br>首先我们来考虑一下线程之间需要哪些通信，我们需要实现哪些功能。</p>
<ul>
<li>回调功能（处理信息的能力）<ul>
<li>在某某事件结束后，执行一个方法。</li>
<li>延迟一段时间后，执行一个方法。</li>
</ul>
</li>
<li>发现信息的能力</li>
<li>把信息送往正确目的地的能力</li>
</ul>
<p>##主要用法和实现</p>
<p>###用法<br>主要用法有两种，一种为<code>view.postXXX()</code>系；另一种为直接调用<code>Handler</code>产生。</p>
<p>调用handler时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">	Handler mHandler;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">proteced <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mHandler = <span class="keyword">new</span> Hanlder() &#123;	</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	            <span class="comment">//onHandleIntent((Intent)msg.obj);</span></span><br><span class="line">	            <span class="comment">//stopSelf(msg.arg1);</span></span><br><span class="line">	        &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runable()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			Message msg = mHandler.obtainMessage();<span class="comment">//这里是Message池</span></span><br><span class="line">			mHandler.sendMessage(msg);<span class="comment">//内部调用，sendMessageDelayed(msg,0);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###原理<br>在某一线程中调用<code>mHandler.sendMessage(Message msg)</code>方法，并且由<em>同一个</em><code>mHanlder</code>引用在另一个特定线程中处理</p>
<p>那么问题来了：<br>要传递的信息从哪来？<br>是什么？<br>准备到哪里去？</p>
<p>####从哪来？</p>
<ul>
<li><code>mHandler.obtainMessage(){ return Message.obtainMessage(this)}</code></li>
<li>调用Message类的静态方法<code>Message.obtainMessage(Handler handler)</code><ul>
<li><code>此处的handler将被传给msg.target变量决定到哪里去问题</code></li>
</ul>
</li>
<li>Message的静态方法有统一调用<code>obtain()</code>方法，从<code>global message pool</code> 中获取一个Message实例<ul>
<li><code>globle message pool</code>的实现值得一提</li>
<li>这个pool使用链表来实现，靠<code>msg.next()</code>链接起来。在类中只保存一个引用。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * Return a new Message instance from the global pool. Allows us to</span><br><span class="line">     * avoid allocating new objects in many cases.</span><br><span class="line">     */</span><br><span class="line">    public static Message obtain() &#123;</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            if (sPool != null) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = null;</span><br><span class="line">                m.flags = 0; // clear in-use flag</span><br><span class="line">                sPoolSize--;</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Message();</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">###是什么？</span><br><span class="line"></span><br><span class="line">Handler只是传递一些简单的信息</span><br><span class="line">- `int what` 通常是用来在`handleMessage`时做判断信息是由哪个地方来的</span><br><span class="line">- `int arg1` 额外变量</span><br><span class="line">- `int arg2` 额外变量</span><br><span class="line">- `Object object` 可以传递一些Runable方法</span><br><span class="line"></span><br><span class="line">###到哪去？</span><br><span class="line">`sendMessage`会把该信息打上`target`标签，然后入队（这里传入`MessageQueue`，还不是`Loop`）`Handler` 中的`enqueueMessage`会调用`MessageQueue`的`enqueueMessage`</span><br><span class="line">```java</span><br><span class="line">//class Handler </span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">	msg.target = this;</span><br><span class="line">	if (mAsynchronous) &#123;</span><br><span class="line">		msg.setAsynchronous(true);</span><br><span class="line">	&#125;// lock to make it asynchronous</span><br><span class="line">	return queue.enqueueMessge(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>此处所入的队列<code>Queue</code>由<code>msg.next</code>的连接起来的链表，队列的顺序受时间的影响，即时间靠前的排在前面。特殊情况：如果比表头还靠前，需要更新表头，此时要多加一句<code>needWake = mBlocked;</code>，以便后面<code>nativeWake(mPtr)</code>唤醒。</p>
<p><strong>注意：</strong> 表头保存在<code>MessageQueue</code>类<code>mPtr</code>中</p>
<p><code>Handler</code>中的这个<code>MessageQueue</code>实例由<code>Looper</code>实例获得，<code>Looper</code>实例由<code>Looper.myLooper()</code>静态方法获得(或者初始化时传入的<code>Looper</code>)，这一动作在构造函数中进行。</p>
<p><strong>所以，信息到底被传递给哪个线程，关键在于<code>Handler</code>在哪里初始化，或者初始化时传入的<code>Looper</code>参数</strong></p>
<p><strong>想获取特定的<code>Looper</code>对象，只要用<code>thread.getLooper</code>就好</strong></p>
<p><code>Looper</code>和<code>MessageQueue</code>是绑定的，一对一的<strong>聚合关系</strong>。一个线程内，<code>Looper</code>的初始化函数会调用<code>MessageQueue</code>的初始化函数。</p>
<p>###取与送<br>如何把特定的<code>Message</code>交给特定的<code>Handler</code>？我们需要把<code>Message</code>从<code>MessageQueue</code>中取出来，并且送到特定的<code>Handler</code>中，这个工作由<code>Looper</code>负责。</p>
<p><strong>Looper与线程是一一对应的</strong>，也就是说，每条线程有且只能有一个Looper来管理信息。<br>这种一一对应的关系是由Looper类中的一个静态变量<code>mThreadLocal</code>实现的。</p>
<p>该变量的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure></p>
<p>再看<code>Looper.prepare()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以及<code>Looper.myLooper()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Return the Looper object associated with the current thread.  Returns</span><br><span class="line">    * null if the calling thread is not associated with a Looper.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadLocal是一种特殊的多线程变量结构，在Python等语言中也有不同程度的支持<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Implements a thread-local storage, that is, a variable for which each thread</span><br><span class="line"> * has its own value. All threads share the same &#123;<span class="doctag">@code</span> ThreadLocal&#125; object,</span><br><span class="line"> * but each sees a different value when accessing it, and changes made by one</span><br><span class="line"> * thread do not affect the other threads. The implementation supports</span><br><span class="line"> * &#123;<span class="doctag">@code</span> null&#125; values.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> java.lang.Thread</span><br><span class="line"> * <span class="doctag">@author</span> Bob Lee</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该类由一个哈希表来实现，由每个线程本身作为key，取出value</p>
<p><strong>Looper类用死循环来取信息</strong>，该动作在<code>Looper.loop()</code>方法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Run the message queue in this thread. Be sure to call</span><br><span class="line">    * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">	...</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Message msg = queue.next(); <span class="comment">// might block(这里面也有一个死循环)</span></span><br><span class="line">        ...</span><br><span class="line">           msg.target.dispatchMessage(msg);</span><br><span class="line">		...</span><br><span class="line">           msg.recycleUnchecked();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> <code>Looper</code>（以及其包含的<code>MessageQueue</code>）都与线程关联，后者与前者同时初始化。二者中皆包含死循环，来不断的读取信息。</p>
<p><strong>再注：</strong>在主线程中肯定不能有死循环，该怎么办呢？<code>Looper</code>中专门为<code>mainThread</code>留了一个变量<code>sMainLooper</code>，其实还是由<code>myLoop()</code>方法赋值，也就是说还是保存在<code>mThreadLocal</code>中。<br>（傻逼了）<br>主线程这里也是这个死循环，不停的更新UI，读缓存绘制到屏幕上。其它GUI正这种死循环也非常常见，典型的<strong>控制反转</strong></p>
<p>##应用范例：IntentService</p>
<p>IntentService 可以在另一个线程中异步的执行一个任务。那么它是怎么在不同的线程中通讯的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Service</span><span class="params">(Looper looper)</span></span>&#123; <span class="keyword">super</span>(looper); &#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">			onHandleIntent((Intent)msg.obj);</span><br><span class="line">			stopSelf(msg.arg1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		mServiceLooper = thread.getLooper();</span><br><span class="line">		mServiceHandler = <span class="keyword">new</span> mServiceHandler(mServiceLooper);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">		Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">		msg.arg1 = startId;</span><br><span class="line">		msg.obj = intent;</span><br><span class="line">		mService.sendMessage(msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	onStartCommand()&#123; onStart(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实说白了，就是Handler在主线程中把信息发给子线程，并且在子线程中执行Handler的handleMessage方法。<br>这是因为，Handler的初始化时传入了特定的Looper，也就与子线程绑定了。Looper的死循环在子线程中进行，自然dispatchMessage()以及handleMessaged()方法都在子线程中进行。也就实现了异步任务。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://LionelCursor.github.io/2015/03/30/Android-Handler-and-Loop/" data-id="cinuzx9bs00000kc09hq13kyx" class="article-share-link">Cuota</a><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/SourceCode/">SourceCode</a><a href="/tags/Concurrent/">Concurrent</a></div><div class="post-nav"><a href="/2015/04/07/Hexo常用命令/" class="pre">Hexo常用命令</a><a href="/2015/03/30/AsyncTask-analysis/" class="next">AsyncTask 原理分析</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://LionelCursor.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categorías</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Foundation/">Foundation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Etiquetas</i></div><div class="tagcloud"><a href="/tags/Interview/" style="font-size: 15px;">Interview</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Concurrent/" style="font-size: 15px;">Concurrent</a> <a href="/tags/Alg/" style="font-size: 15px;">Alg</a> <a href="/tags/DataStructure/" style="font-size: 15px;">DataStructure</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Quick-Reference/" style="font-size: 15px;">Quick Reference</a> <a href="/tags/Others/" style="font-size: 15px;">Others</a> <a href="/tags/Canvas/" style="font-size: 15px;">Canvas</a> <a href="/tags/Summary/" style="font-size: 15px;">Summary</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/SourceCode/" style="font-size: 15px;">SourceCode</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/OpenSource/" style="font-size: 15px;">OpenSource</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/500L/" style="font-size: 15px;">500L</a> <a href="/tags/aosabook/" style="font-size: 15px;">aosabook</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/alg/" style="font-size: 15px;">alg</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recientes</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/06/译-信号系统分析实践——计步器/">[译]信号系统分析实践——计步器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/用JUnit与Mock框架对Android项目进行单元测试/">用JUnit与Mock框架对Android项目进行单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/19/onCreate方法的一次debug/">onCreate方法的一次debug</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/Logger-in-xUtils/">Logger in xUtils</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/29/computer_network/">计算机网络知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/LeakCanary原理分析/">LeakCanary原理分析 [转载]</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/zxing-android-client/">zxing-android-client</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/RxJava3/">ReactiveX Operator 总结 及其它重要概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/RxJava2/">RxJava原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/22/RxJava/">RxJava基础应用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://github.com/LionelCursor" title="我的github" target="_blank">我的github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Damon Lei.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?06d5a7998bcfa3c5d037974c6aa847fc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>