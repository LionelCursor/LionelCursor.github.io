<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="在年轻的时候，或修道还没有成功的时候，或者倒霉得没有办法的时候，就要“沉潜”在深水里，动都不要动。"><title>RxJava原理 | Damon Lei</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RxJava原理</h1><a id="logo" href="/.">Damon Lei</a><p class="description">在年轻的时候，或修道还没有成功的时候，或者倒霉得没有办法的时候，就要“沉潜”在深水里，动都不要动。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RxJava原理</h1><div class="post-meta">Feb 24, 2016<span> | </span><span class="category"><a href="/categories/android/">android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">Inhalte</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#从map函数说起"><span class="toc-number">1.</span> <span class="toc-text">从map函数说起</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#那么RxJava是怎么实现map的呢？"><span class="toc-number">1.1.</span> <span class="toc-text">那么RxJava是怎么实现map的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用自然语言描述。"><span class="toc-number">1.1.1.</span> <span class="toc-text">用自然语言描述。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用代码描述"><span class="toc-number">1.1.2.</span> <span class="toc-text">用代码描述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#所以我们就可以解答第一个问题了。"><span class="toc-number">1.2.</span> <span class="toc-text">所以我们就可以解答第一个问题了。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制数据的流向——flatMap"><span class="toc-number">2.</span> <span class="toc-text">控制数据的流向——flatMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMap的作用"><span class="toc-number">2.1.</span> <span class="toc-text">flatMap的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMap原理"><span class="toc-number">2.2.</span> <span class="toc-text">flatMap原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程是如何生效的"><span class="toc-number">3.</span> <span class="toc-text">线程是如何生效的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subscription-unsubscribe方法"><span class="toc-number">4.</span> <span class="toc-text">Subscription#unsubscribe方法</span></a></li></ol></div></div><div class="post-content"><p>我在前面提到了几个问题，下面将尽可能的试着把它们说明白。</p>
<ol>
<li>map函数的Func是以什么形式，存储在哪里，在何时，由谁操控着，来处理订阅和观察的结果(参数)的？如果有n层map，那么这种关系将较为复杂。</li>
<li>flatMap是怎样的原理？和map有什么区别</li>
<li>线程是如何生效的？</li>
<li>subscription在unsubscribe的时候，仅仅取消了订阅者的关注，还是停下了整个调用链？</li>
</ol>
<a id="more"></a>
<h2 id="从map函数说起"><a href="#从map函数说起" class="headerlink" title="从map函数说起"></a>从map函数说起</h2><p>如果我们自己构造map函数的时候，我们会怎么构造？<br>我是这样想的，我会定义一个Subscriber来接收，同时穿件一个新的Observable来发送新的信号，当接收到一个信号的时候，处理，然后就由新的Observable发送一个。<br>在这中间，或是在Subscriber，或是在Observable中用Func来处理Event。即可达到map的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Subscriber mFatherSubscriber = null;</span><br><span class="line">Observable mChildObservable = null;</span><br><span class="line">Observable Father = this;</span><br><span class="line"></span><br><span class="line">public Observable&lt;Event&gt; map(Func) &#123;</span><br><span class="line">    mChildObservable = Observable.create(new OnSubscriber&#123;</span><br><span class="line">        call(Subscriber s) &#123;</span><br><span class="line">            s.onNext(Event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    this.mFatherSubscriber = new Subscriber() &#123;</span><br><span class="line">        onNext(Event) &#123;</span><br><span class="line">            mChildObservable.emit(Func(Event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return mChildObservable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样确实可以实现map的功能，但是对比RxJava的实现，有以下几点不足，或者说没有考虑到。</p>
<p>第一，打破了完全的函数式编程结构。这样的话需要给Observable留出转发的接口，而Observable对应着的却是产生事件的行为，没有接收信息的行为。而给他加上这个接口，整个思想就会造成混乱，无法让用户很好的体验到事件流的魅力。</p>
<p>第二，各个级别拆的太散了，想要控制后面的行为，比如控制后面的map执行的线程，就需要把这样那样的信息也传递下去。这需要预留大量的接收入口，不太好。</p>
<p>第三，更加复杂的结构，比如flatMap相对来说，就不好兼容。而RxJava却用Operator类将所有的行为统一到了一起。</p>
<h3 id="那么RxJava是怎么实现map的呢？"><a href="#那么RxJava是怎么实现map的呢？" class="headerlink" title="那么RxJava是怎么实现map的呢？"></a>那么RxJava是怎么实现map的呢？</h3><h4 id="用自然语言描述。"><a href="#用自然语言描述。" class="headerlink" title="用自然语言描述。"></a>用自然语言描述。</h4><p>我先用语言简单描述一下，然后再深入到代码中。</p>
<p>在研究map之前，我想再啰嗦一遍subscribe()函数运行的过程。</p>
<p>在subscribe函数中，有两个操作对象，一个是被调用的Observable事件源，一个是传进来的Subscriber接收者。<br>当subscribe调用的时候，就会把Subscriber交给Observable，由Observable来进行调用。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void static subscribe(Subscriber s, Observable o) &#123;</span><br><span class="line">    s.onStart();</span><br><span class="line">    try &#123;</span><br><span class="line">        o.onSubscriber.call(s);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            s.onError(e);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw_it(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，会有一个动作，就是把Subscriber交给Observable里的OnSubscriber，并进行进一步处理。</p>
<p>OK，让我们回到map的问题上。</p>
<p>当执行map(Func)的时候，会构建一个新的Observable（这个构建的过程叫做lift()）。如果紧跟着map后面调用subscribe的话，那么一个Subscriber就会被交给这个Observable。</p>
<p>那么这个新的夹在数据源Observable和订阅者Subscriber之间的Observable都做了哪些事呢？</p>
<p>这个Observable会把接收到的Subscriber首先包装成一个新的Subscriber，新的Subscriber会把传来的信号先经过Func处理，然后再交给被包装的那个Subscriber。</p>
<p>然后介于中间的Observable会把这个包装过的Subscriber交给上一级的OnSubscriber来处理。上一级的OnSubscriber中也可能有自己的处理方式，比如再把Subscriber包装一层，直到遇到真正的数据源，开始给这包装了一层又一层的Subscriber传递数据，这一层又一层的包装，就是一层又一层的中间函数处理。</p>
<h4 id="用代码描述"><a href="#用代码描述" class="headerlink" title="用代码描述"></a>用代码描述</h4><p>我们依旧从map函数看进去，然后了解Operator类，以及lift函数。</p>
<p>Observable#map方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//T是当前所在的Observable实例的T泛型，代表这一级传递过来的参数的类型，</span><br><span class="line">//而R则是在这个Func1中传入的，能够规定新产生的Observable类型。</span><br><span class="line">public &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;T, R&gt; func) &#123;</span><br><span class="line">    //首先把func包装成了一个OperatorMap，再经过lift生成新的Observable</span><br><span class="line">    return lift(new OperatorMap&lt;T, R&gt;(func));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OperatorMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public final class OperatorMap&lt;T, R&gt; implements Operator&lt;R, T&gt; &#123;</span><br><span class="line">    //记录传进来的map函数</span><br><span class="line">    private final Func1&lt;? super T, ? extends R&gt; transformer;</span><br><span class="line">    //构造函数没有什么好说的</span><br><span class="line">    public OperatorMap(Func1&lt;? super T, ? extends R&gt; transformer) &#123;</span><br><span class="line">        this.transformer = transformer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //这个函数有一点意思了，会把传进来的Subscriber包装成新的Subscriber。</span><br><span class="line">    //但是有趣的是，新的Subscriber只有在这个函数被调用的时候才会被创建，</span><br><span class="line">    //或者说，只有在拿到Subscriber的时候，才会包装它创建这个新的Subscriber。</span><br><span class="line">    //而在此之前呢，函数Func1被保存在这个叫做Operator的对象中，</span><br><span class="line">    //而这个Operator则会保存在Obervable中，通过闭包的方式，非常的奇妙。</span><br><span class="line">    @Override</span><br><span class="line">    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super R&gt; o) &#123;</span><br><span class="line">        return new Subscriber&lt;T&gt;(o) &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onCompleted() &#123;</span><br><span class="line">                o.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable e) &#123;</span><br><span class="line">                o.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(T t) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    o.onNext(transformer.call(t));</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    Exceptions.throwOrReport(e, this, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们归纳一下OperatorMap的作用。暂时存储Func1，需要的时候，就会把传进来的Subscriber包装上Func形成新的Subscriber。我们可以说，这个Operator生成了一个新函数，返回了出来。有点函数式编程的意思了吧。</p>
<p>Observable#lift函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//注意参数这个final，这个Operator将被保存在内部类中，其中的函数也得到了保存，</span><br><span class="line">//并在以后这个新生成的Observable被调用的时候，生成一个新的包装过的Subscriber</span><br><span class="line">public &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;R, T&gt; o) &#123;</span><br><span class="line">    //lift函数新建了一个Observable</span><br><span class="line">    return new Observable&lt;R&gt;(new OnSubscribe&lt;R&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(Subscriber&lt;? super R&gt; s) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //包装出来的新函数。</span><br><span class="line">                    Subscriber&lt;? super T&gt; st = o.call(s);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        st.onStart();</span><br><span class="line">                        //将交给st交给上一级Observable处理。</span><br><span class="line">                        //上一级Observable也是保存在这一内部类实例中。</span><br><span class="line">                        onSubscribe.call(st);</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        st.onError(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    s.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="所以我们就可以解答第一个问题了。"><a href="#所以我们就可以解答第一个问题了。" class="headerlink" title="所以我们就可以解答第一个问题了。"></a>所以我们就可以解答第一个问题了。</h3><p>map函数的Func是以什么形式，存储在哪里，在何时，由谁操控着，来处理订阅和观察的结果(参数)的？如果有n层map，那么这种关系将较为复杂。</p>
<p>map函数的func储存在Operator中，Operator储存在map函数返回的新的Observable中，以闭包的形式保存在实例中。</p>
<p>在调用subscribe的时候才会被使用，首先由Operator包装到下级传上来的Subscriber上面。然后再统一传给上级，最后，传到源头的时候，就会被调用。</p>
<p>先溯流而上，不断包装，不断保存下设置的信息，不管是函数也好，线程控制也好通通都会被包装被记录下来。溯流到源头以后，数据源传递过来的数据，就会沿着各层包装制定好的路线一次运行。</p>
<h2 id="控制数据的流向——flatMap"><a href="#控制数据的流向——flatMap" class="headerlink" title="控制数据的流向——flatMap"></a>控制数据的流向——flatMap</h2><p>前面已经说了，RxJava优势的第二点是明晰的事件流模型，这个所谓的流反应在时间上，一段时间内持续不断的有事件传来，形成一个流，如何控制这种流，流量，流向，ReactiveX都提供了相当优雅的解决方案。</p>
<h3 id="flatMap的作用"><a href="#flatMap的作用" class="headerlink" title="flatMap的作用"></a>flatMap的作用</h3><p>我首先还是用自然语言来简单介绍一下flatMap<br><img src="/images/flatMap.png" alt=""><br>flatMap接收一个事件的数据，返回一个Observable。这是什么意思呢，函数内部会首先执行这个新返回的Observable，把这个Observable的事件全部都发给Subscriber，再接着返回源头的Observable，继续给flatMap发事件，以此类推。</p>
<h3 id="flatMap原理"><a href="#flatMap原理" class="headerlink" title="flatMap原理"></a>flatMap原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final &lt;R&gt; Observable&lt;R&gt; flatMap(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; func) &#123;</span><br><span class="line">        return merge(map(func));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先Fuc经过了一层map，这意味着map返回的是一个Observable<observable>。前面也说了，map相当于对Subscriber进行了一层处理。现在最底端的这个Observable返回的是一个Observable。</observable></p>
<p>然后再看merge函数，merge函数将对这个Observable再向下处理一层。（现在Rxjava所谓的Observable串的结构体系已经初现端倪了）</p>
<p>merge()发生了什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; source) &#123;</span><br><span class="line">        return source.lift(OperatorMerge.&lt;T&gt;instance(false));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>source对应着map返回的一个Observable，这个map返回的Observable传递的是Observable信号。对它进行lift，意味着用OperatorMerge接收下级Subscriber进行包装生成新的Subscriber。再交给上级的Observable。这个新的Subscriber接收的是Observable<t>信号，交给下一级的Subscriber时(通过参数传入)，交的是T类型的信号。</t></p>
<p>所以答案就呼之欲出了，就是把Observable<t>中的信号通通发送给下一级的Subscriber。这一个信号就算是处理完了。</t></p>
<p>我们来归纳下，merge函数的作用，能够把Observable<observable<t>&gt; 处理成 Observable<t>，即把Observable<t>类型的输入，通过emitLoop()，把这个Observable里的数据全部发出，交给下一级的Subscriber，从而变成输出T类型的Observable</t></t></observable<t></p>
<h2 id="线程是如何生效的"><a href="#线程是如何生效的" class="headerlink" title="线程是如何生效的"></a>线程是如何生效的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123;</span><br><span class="line">        // 在事件源执行时，通过OperatorObserveOn对于Subscriber进行包装。</span><br><span class="line">        return lift(new OperatorObserveOn&lt;T&gt;(scheduler));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在事件源执行时，通过OperatorObserveOn对于Subscriber进行包装。</p>
<p>其实这层包装，就是一层线程切换，决定了，接下来的任务（下级的Subscriber，或者说内层的Subscriber）在哪个线程执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123;</span><br><span class="line">    return nest().lift(new OperatorSubscribeOn&lt;T&gt;(scheduler));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public final Observable&lt;Observable&lt;T&gt;&gt; nest() &#123;</span><br><span class="line">    return just(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nest其实就是把现在的Observable进行返回。我们姑且把这个叫做<code>obs_A</code>，对它进行lift意味着，把传给它的Subscriber先用OperatorSubscribeOn进行包装，然后再交给上级Observable进行执行。</p>
<p>也就是说<code>obj_A</code>返回的Observable，会交给OperatorSubscribeOn生成的新Subscriber，而新Subscriber保存着内层的Subscribe。再进行进一步传递。于是，就有了机会在这中间进行线程的切换。</p>
<h2 id="Subscription-unsubscribe方法"><a href="#Subscription-unsubscribe方法" class="headerlink" title="Subscription#unsubscribe方法"></a>Subscription#unsubscribe方法</h2><p>OK，现在我们已经很清楚，每一个map，flatMap，subscribeOn，observeOn等等等，其实都是构建了一个新的Observable，也就是说构成了一个Observable串。</p>
<p>那么，当调用unsubscribe的时候，发生了什么呢？是整个Observable链条每一节都会断掉吗？</p>
<p>unsubscribe方法是Subscriber里的一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription &#123;</span><br><span class="line">    private final SubscriptionList subscriptions;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public final void unsubscribe() &#123;</span><br><span class="line">        subscriptions.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来，所有的Subscriber都被存储在一起了，我们再看一下SubscriptionList。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public final class SubscriptionList implements Subscription &#123;</span><br><span class="line"></span><br><span class="line">    private LinkedList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    </span><br><span class="line">    public void add(final Subscription s) &#123; </span><br><span class="line">        // add in linkedList</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void remove(final Subscription s) &#123; </span><br><span class="line">        // remove from linkedList</span><br><span class="line">    &#125;</span><br><span class="line">    //经过一些列的同步判断，对于Subscriptions中保存的所有Subscriber，调用unsubscribe()</span><br><span class="line">    @Override</span><br><span class="line">    public void unsubscribe() &#123;</span><br><span class="line">        if (!unsubscribed) &#123;</span><br><span class="line">            List&lt;Subscription&gt; list;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (unsubscribed) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                unsubscribed = true;</span><br><span class="line">                list = subscriptions;</span><br><span class="line">                subscriptions = null;</span><br><span class="line">            &#125;</span><br><span class="line">            // we will only get here once</span><br><span class="line">            unsubscribeFromAll(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static void unsubscribeFromAll(Collection&lt;Subscription&gt; subscriptions) &#123;</span><br><span class="line">        if (subscriptions == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Throwable&gt; es = null;</span><br><span class="line">        for (Subscription s : subscriptions) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                s.unsubscribe();</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                if (es == null) &#123;</span><br><span class="line">                    es = new ArrayList&lt;Throwable&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                es.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Exceptions.throwIfAny(es);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中看，其实就是调用一个Subscriber的unsubscribe的时候，就是对于在SubscriptionList中的所有Subscriber调用unsubscribe。</p>
<p>那么SubscriptionList中都有哪些Subscriber呢？</p>
<p>我们知道Operator的实质是对Subscriber进行包装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super R&gt; o) &#123;</span><br><span class="line">    return new Subscriber&lt;T&gt;(o) &#123;</span><br><span class="line">        // implement</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，包装过的外层的Subscriber，在构造的时候，会把内层的订阅者传进来。<br>我们来看一下Subscriber的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected Subscriber(Subscriber&lt;?&gt; subscriber) &#123;</span><br><span class="line">    this(subscriber, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Subscriber(Subscriber&lt;?&gt; subscriber, boolean shareSubscriptions) &#123;</span><br><span class="line">    this.subscriber = subscriber;</span><br><span class="line">    this.subscriptions = shareSubscriptions &amp;&amp; subscriber != null ? subscriber.subscriptions : new SubscriptionList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是所有的Subscriber其实都共享着同一个SubscriptionList，换句话说，记录了所有的Subscriber。同时SubscriptionList还有一个boolean型的标记，标记着是否已经停止。在需要时，就会针对这个进行类型进行判断，看是否该终止这一发送行为。</p>
<p>以下是Observable.from(Iterable)对应的OnSubscriber的call函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void call(final Subscriber&lt;? super T&gt; o) &#123;</span><br><span class="line">    final Iterator&lt;? extends T&gt; it = is.iterator();</span><br><span class="line">    if (!it.hasNext() &amp;&amp; !o.isUnsubscribed())</span><br><span class="line">        o.onCompleted();</span><br><span class="line">    else </span><br><span class="line">        o.setProducer(new IterableProducer&lt;T&gt;(o, it));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在这个函数中，就对于是否已经停止订阅进行了判断。</p>
<p>所以，当我们调用unsubscribe的时候，整个Observable调用链，不一定全部断裂，而是看需求，有需求（持续发送信号）的Observable，就会判断Subscriber是否停止接受。而Subscriber之所以可以看到最底端，或者最内层的Subscriber是否接收信号，是因为他们共享着同一个SubscriptionList作为判断标识。</p>
<p>所以，要注意，unsubscribe只是标明Subscriber对于这个事件源不感兴趣了，但是不意味着，Observable以及中间层的各个Observable会立刻停止发送信息，有时，即便没有了订阅者，Observable也还是会继续发送信息。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://LionelCursor.github.io/2016/02/24/RxJava2/" data-id="cimytns1a00137fgx9ery4ufj" class="article-share-link">Aktie</a><div class="tags"><a href="/tags/android/">android</a><a href="/tags/RxJava/">RxJava</a></div><div class="post-nav"><a href="/2016/02/24/RxJava3/" class="pre">ReactiveX Operator 总结 及其它重要概念</a><a href="/2016/02/22/RxJava/" class="next">RxJava基础应用</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://LionelCursor.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Foundation/">Foundation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Interview/" style="font-size: 15px;">Interview</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/SourceCode/" style="font-size: 15px;">SourceCode</a> <a href="/tags/Concurrent/" style="font-size: 15px;">Concurrent</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Canvas/" style="font-size: 15px;">Canvas</a> <a href="/tags/Alg/" style="font-size: 15px;">Alg</a> <a href="/tags/DataStructure/" style="font-size: 15px;">DataStructure</a> <a href="/tags/Quick-Reference/" style="font-size: 15px;">Quick Reference</a> <a href="/tags/Others/" style="font-size: 15px;">Others</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Summary/" style="font-size: 15px;">Summary</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/OpenSource/" style="font-size: 15px;">OpenSource</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/alg/" style="font-size: 15px;">alg</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/用JUnit与Mock框架对Android项目进行单元测试/">用JUnit与Mock框架对Android项目进行单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/19/onCreate方法的一次debug/">onCreate方法的一次debug</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/Logger-in-xUtils/">Logger in xUtils</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/29/computer_network/">计算机网络知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/LeakCanary原理分析/">LeakCanary原理分析 [转载]</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/zxing-android-client/">zxing-android-client</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/RxJava3/">ReactiveX Operator 总结 及其它重要概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/RxJava2/">RxJava原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/22/RxJava/">RxJava基础应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/22/初试ios开发/">初试ios开发</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://github.com/LionelCursor" title="我的github" target="_blank">我的github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Damon Lei.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?06d5a7998bcfa3c5d037974c6aa847fc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>