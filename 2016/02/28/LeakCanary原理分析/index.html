<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="在年轻的时候，或修道还没有成功的时候，或者倒霉得没有办法的时候，就要“沉潜”在深水里，动都不要动。"><title>LeakCanary原理分析 [转载] | Damon Lei</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LeakCanary原理分析 [转载]</h1><a id="logo" href="/.">Damon Lei</a><p class="description">在年轻的时候，或修道还没有成功的时候，或者倒霉得没有办法的时候，就要“沉潜”在深水里，动都不要动。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Inicio</i></a><a href="/archives/"><i class="fa fa-archive"> Archivo</i></a><a href="/about/"><i class="fa fa-user"> Acerca de</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LeakCanary原理分析 [转载]</h1><div class="post-meta">Feb 28, 2016<span> | </span><span class="category"><a href="/categories/android/">android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><a id="more"></a>
<blockquote>
<p><a href="http://coolpers.github.io/leakcanary%7Cmat/2015/06/04/LeakCanary-Brief.html" target="_blank" rel="external">原文链接</a></p>
</blockquote>
<p>导语：</p>
<blockquote>
<p>提到Java语言的特点，无论是教科书还是程序员一般都会罗列出面向对象、可移植性及安全等特点。但如果你是一位刚从C/C++转到Java的程序员，对Java语言的特性除了面向对象之外，最外直接的应当是在Java虚拟机（JVM）在内存管理方面给我们变成带来的便利。JVM的这一大特性使Java程序员从繁琐的内存管理工作中得到了一定解放，但是JVM的这个特点的实现也是有代价的，并且它也并非万能。因此如果一个编程习惯不好的Java程序员如果完全将内存回收寄希望于JVM，那么OOM（Out Of Memory）就已经悄悄潜伏在了他的程序之中。</p>
<p>Android应用基于Java实现，因此它也将Java的优缺点继承了过来。相对来说，移动设备对于内存问题更为敏感，程序在申请一定的内存但又没有及时得到释放后就很容易发生OOM而导致crash。因此Android程序员开发过程中一般都会定时排查自己程序中可能出现的这些雷点，尽可能地避免因为crash问题而影响用户体验。</p>
</blockquote>
<h2 id="LeakCanary简介"><a href="#LeakCanary简介" class="headerlink" title="LeakCanary简介"></a>LeakCanary简介</h2><p>目前Java程序最常用的内存分析工具应该是MAT（Memory Analyzer Tool），它是一个Eclipse插件，同时也有单独的RCP客户端，也可以通过官网的SVN下载到它的源码（具体见另一篇《compile-MAT》）并编译成jar包。LeakCanary本质上就是一个基于MAT进行Android应用程序内存泄漏自动化检测的的开源工具，通过集成这个工具代码到自己的Android工程当中就能够在程序调试开发过程中通过一个漂亮的界面（如下图）随时发现和定位内存泄漏问题，而不用每次在开发流程中都抽出专人来进行内存泄漏问题检测，极大地方便了Android应用程序的开发。 </p>
<p><img src="http://coolpers.github.io/assets/posts/2015-06-16-LeakCanary-Brief/LeakCanary_result.png" alt=""></p>
<p>总的来说，LeakCanary有如下几个明显优点：</p>
<ul>
<li>针对Android Activity组件完全自动化的内存泄漏检查。</li>
<li>可定制一些行为（dump文件和leaktrace对象的数量、自定义例外、分析结果的自定义处理等）。</li>
<li>集成到自己工程并使用的成本很低。</li>
<li>友好的界面展示和通知。</li>
</ul>
<p>如你现在想集成LeakCanary到自己的工程中，那么你只需要做以下工作： 1. 导入leakcanary的jar包到自己工程（下载链接：leakcanary.zip） 2. 在4.0以上，只需要在工程的Application的onCreate函数中按照如下的方式加入一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleApplication extends Application &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        LeakCanary.install(this);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.0以下在需要进行内存泄漏监控的Activity的onDestroy方法中按如下加入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    // start watch</span><br><span class="line">    HeapDump.Listener heapDumpListener =</span><br><span class="line">    new ServiceHeapDumpListener(this, listenerServiceClass);</span><br><span class="line">    DebuggerControl debuggerControl = new AndroidDebuggerControl();</span><br><span class="line">    AndroidHeapDumper heapDumper = new AndroidHeapDumper();</span><br><span class="line">    heapDumper.cleanup();</span><br><span class="line">    ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults().build();</span><br><span class="line">    RefWatcher refWatcher = new RefWatcher(new AndroidWatchExecutor(), debuggerControl, GcTrigger.DEFAULT,</span><br><span class="line">    heapDumper, heapDumpListener, excludedRefs);</span><br><span class="line">&#125; 　　第二种情况下，在有多个Activity需要检测的情况看起来稍显繁琐，实际上可以用以上方法实现一个基类Activity，之后需要内存泄漏检测的Activity直接继承这个基类Activity就不需要每次都重复处理oonDestroy方法了。并且以上代码只作为示例，实际上每次watch的时候并不需要重新new一个RefWatcher对象，因为这个对象是可以重复使用的。</span><br></pre></td></tr></table></figure>
<p>完成了以上两个步骤后，LeakCanary就可以为你的工程服务了，这之中需要我们自己处理的工作很少，相比较我们自己手工用MAT进行内存泄漏检测而言，确实方便了很多。 ## 2.LeakCanary原理分析 ## 这么强大的工具，它是如何实现的呢，引用LeakCanary中文使用说明，它的基本工作原理如下：</p>
<p>RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。<br>然后在后台线程检查引用是否被清除，如果没有，调用GC。<br>如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。<br>在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA 解析这个文件。<br>得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄漏。<br>HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。<br>引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。<br>但事实上一切并没那么简单，LeakCanary的设计者在实现的时候实际上为我们考虑了很多细节。可以通过源码分析来走一遍一次内存泄漏检查的流程。 在一个Activity生命周期结束调用oonDestroy方法的时候会触发LeakCanary进行一次内存泄漏检查，LeakCanary开始进行检查的入口函数实际上是RefWatcher类的，watch方法，其源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void watch(Object watchedReference, String referenceName) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  String key = UUID.randomUUID().toString();</span><br><span class="line">  retainedKeys.add(key);</span><br><span class="line">  final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class="line"></span><br><span class="line">  watchExecutor.execute(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          ensureGone(reference, watchStartNanoTime);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; 这个函数做的主要工作就是为需要进行泄漏检查的Activity创建一个带有唯一key标志的弱引用，并将这个弱引用key保存至retainedKeys中，然后将后面的工作交给watchExecutor来执行。这个watchExecutor在LeakCanary中是AndroidWatchExecutor的实例，调用它的execute方法实际上就是向主线程的消息队列中插入了一个IdleHandler消息，这个消息只有在对应的消息队列为空的时候才会去执行，因此RefWatcher的watch方法就保证了在主线程空闲的时候才会去执行ensureGone方法，防止因为内存泄漏检查任务而严重影响应用的正常执行。ensureGone的主要源码如下:</span><br><span class="line"></span><br><span class="line">void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    removeWeaklyReachableReferences();</span><br><span class="line">    if (gone(reference) || debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    gcTrigger.runGc();      // 手动执行一次gc</span><br><span class="line">    removeWeaklyReachableReferences();</span><br><span class="line">    if (!gone(reference)) &#123;</span><br><span class="line"></span><br><span class="line">        long startDumpHeap = System.nanoTime();</span><br><span class="line">        long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line"></span><br><span class="line">        File heapDumpFile = heapDumper.dumpHeap();</span><br><span class="line">        if (heapDumpFile == null) &#123;</span><br><span class="line">            // Could not dump the heap, abort.</span><br><span class="line">            Log.d(TAG, &quot;Could not dump the heap, abort.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line"></span><br><span class="line">        heapdumpListener.analyze(new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs,</span><br><span class="line">                watchDurationMs, gcDurationMs, heapDumpDurationMs));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; 因为这个方法是在主线程中执行的，因此一般执行到这个方法中的时候之前被destroy的那个Activity的资源应该被JVM回收了，因此这个方法首先调用removeWeaklyReachableReferences方法来将引用队列中存在的弱引用从retainedKeys中删除掉，这样，retainedKeys中保留的就是还没有被回收对象的弱引用key。之后再用gone方法来判断我们需要检查的Activity的弱引用是否在retainedKeys中，如果没有，说明这个Activity对象已经被回收，检查结束。否则，LeakCanary主动触发一次gc，再进行以上两个步骤，如果发现这个Activity还没有被回收，就认为这个Activity很有可能泄漏了，并dump出当前的内存文件供之后进行分析。</span><br></pre></td></tr></table></figure>
<p>之后的工作就是对内存文件进行分析，由于这个过程比较耗时，因此最终会把这个工作交给运行在另外一个进程中的HeapAnalyzerService来执行。HeapAnalyzerService通过调用HeapAnalyzer的checkForLeak方法进行内存分析，其源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ISnapshot snapshot = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      snapshot = openSnapshot(heapDumpFile);  </span><br><span class="line"></span><br><span class="line">      IObject leakingRef = findLeakingReference(referenceKey, snapshot);</span><br><span class="line"></span><br><span class="line">      // False alarm, weak reference was cleared in between key check and heap dump.</span><br><span class="line">      if (leakingRef == null) &#123;</span><br><span class="line">        return noLeak(since(analysisStartNanoTime));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String className = leakingRef.getClazz().getName();</span><br><span class="line"></span><br><span class="line">      AnalysisResult result =</span><br><span class="line">          findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, className, true);</span><br><span class="line"></span><br><span class="line">      if (!result.leakFound) &#123;</span><br><span class="line">        result = findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, className, false);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">    &#125; catch (SnapshotException e) &#123;</span><br><span class="line">      return failure(e, since(analysisStartNanoTime));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      cleanup(heapDumpFile, snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法进行的第一步就是利用HAHA将之前dump出来的内存文件解析成Snapshot对象，其中调用到的方法包括SnapshotFactory的parse和HprofIndexBuilder的fill方法。解析得到的Snapshot对象直观上和我们使用MAT进行内存分析时候罗列出内存中各个对象的结构很相似，它通过对象之间的引用链关系构成了一棵树，我们可以在这个树种查询到各个对象的信息，包括它的Class对象信息、内存地址、持有的引用及被持有的引用关系等。到了这一阶段，HAHA的任务就算完成，之后LeakCanary就需要在Snapshot中找到一条有效的到被泄漏对象之间的引用路径。首先它调用findLeakTrace方法来从Snapshot中找到被泄漏对象，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private IObject findLeakingReference(String key, ISnapshot snapshot) throws SnapshotException &#123;</span><br><span class="line"></span><br><span class="line">    Collection&lt;IClass&gt; refClasses =</span><br><span class="line">        snapshot.getClassesByName(KeyedWeakReference.class.getName(), false);</span><br><span class="line"></span><br><span class="line">    if (refClasses.size() != 1) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">          &quot;Expecting one class for &quot; + KeyedWeakReference.class.getName() + &quot; in &quot; + refClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IClass refClass = refClasses.iterator().next();</span><br><span class="line"></span><br><span class="line">    int[] weakRefInstanceIds = refClass.getObjectIds();</span><br><span class="line"></span><br><span class="line">    for (int weakRefInstanceId : weakRefInstanceIds) &#123;</span><br><span class="line">      IObject weakRef = snapshot.getObject(weakRefInstanceId);</span><br><span class="line">      String keyCandidate =</span><br><span class="line">          PrettyPrinter.objectAsString((IObject) weakRef.resolveValue(&quot;key&quot;), 100);  </span><br><span class="line">      if (keyCandidate.equals(key)) &#123;  // 匹配key</span><br><span class="line">        return (IObject) weakRef.resolveValue(&quot;referent&quot;);  // 定位泄漏对象</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalStateException(&quot;Could not find weak reference with key &quot; + key);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>为了能够准确找到被泄漏对象，LeakCanary通过被泄漏对象的弱引用来在Snapshot中定位它。因为，如果一个对象被泄漏，一定也可以在内存中找到这个对象的弱引用，再通过弱引用对象的referent就可以直接定位被泄漏对象。 下一步的工作就是找到一条有效的到被泄漏对象的最短的引用，这通过findLeakTrace来实现，实际上寻找最短路径的逻辑主要是封装在PathsFromGCRootsComputerImpl这个类的getNextShortestPath和processCurrentReferrefs这两个方法当中，其源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public int[] getNextShortestPath() throws SnapshotException &#123;</span><br><span class="line">      switch (state) &#123;</span><br><span class="line">        case 0: // INITIAL</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        case 1: // FINAL</span><br><span class="line">          return null;</span><br><span class="line"></span><br><span class="line">        case 2: // PROCESSING GC ROOT</span><br><span class="line">        &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        case 3: // NORMAL PROCESSING</span><br><span class="line">        &#123;</span><br><span class="line">          int[] res;</span><br><span class="line"></span><br><span class="line">          // finish processing the current entry</span><br><span class="line">          if (currentReferrers != null) &#123;</span><br><span class="line">            res = processCurrentReferrefs(lastReadReferrer + 1);</span><br><span class="line">            if (res != null) return res;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Continue with the FIFO</span><br><span class="line">          while (fifo.size() &gt; 0) &#123;</span><br><span class="line">            currentPath = fifo.getFirst();</span><br><span class="line">            fifo.removeFirst();</span><br><span class="line">            currentId = currentPath.getIndex();</span><br><span class="line">            currentReferrers = inboundIndex.get(currentId);</span><br><span class="line"></span><br><span class="line">            if (currentReferrers != null) &#123;</span><br><span class="line">              res = processCurrentReferrefs(0);</span><br><span class="line">              if (res != null) return res;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int[] processCurrentReferrefs(int fromIndex) throws SnapshotException &#123;</span><br><span class="line">      GCRootInfo[] rootInfo = null;</span><br><span class="line">      for (int i = fromIndex; i &lt; currentReferrers.length; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      for (int referrer : currentReferrers) &#123;</span><br><span class="line">        if (referrer &gt;= 0 &amp;&amp; !visited.get(referrer) &amp;&amp; !roots.containsKey(referrer)) &#123;</span><br><span class="line">          if (excludeMap == null) &#123;</span><br><span class="line">            fifo.add(new Path(referrer, currentPath));</span><br><span class="line">            visited.set(referrer);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if (!refersOnlyThroughExcluded(referrer, currentId)) &#123;</span><br><span class="line">              fifo.add(new Path(referrer, currentPath));</span><br><span class="line">              visited.set(referrer);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>为了是逻辑更清晰，在这里省略了对GCRoot的处理。这个类将整个内存映像信息抽象成了一个以GCRoot为根的树，getNextShortestPath的状态3是对一般节点的处理，由于之前已经定位了被泄漏的对象在这棵树中的位置，为了找到一条到GCRoot最短的路径，PathsFromGCRootsComputerImpl采用的方法是类似于广度优先的搜索策略，在getNextShortestPath中从被泄漏的对象开始，调用一次processCurrentReferrefs将持有它引用的节点（父节点），加入到一个FIFO队列中，然后依次再调用getNextShortestPath和processCurrentReferrefs来从FIFO中取节点及将这个节点的父节点再加入FIFO队列中，一层一层向上寻找，哪条路径最先到达GCRoot就表示它应该是一条最短路径。由于FIFO保存了查询信息，因此如果要找次最短路径只需要再调用一次getNextShortestPath触发下一次查找即可，其算法原理如下图所示。</p>
<p><img src="http://coolpers.github.io/assets/posts/2015-06-16-LeakCanary-Brief/shortest_path.png" alt=""></p>
<p>至此，主要的工作就完成了，后面就是调用buildLeakTrace构建查询结果，这个过程相对简单，仅仅是将之前查找的最短路径转换成最后需要显示的LeakTrace对象，这个对象中包括了一个由路径上各个节点LeakTraceElement组成的链表，代表了检查到的最短泄漏路径。最后一个步骤就是将这些结果封装成AnalysisResult对象然后交给DisplayLeakService进行处理。这个service主要的工作是将检查结果写入文件，以便之后能够直接看到最近几次内存泄露的分析结果，同时以notification的方式通知用户检测到了一次内存泄漏。使用者还可以继承这个service类来并实现afterDefaultHandling来自定义对检查结果的处理，比如将结果上传刚到服务器等。</p>
<p>以上就是对LeakCanary源码的分析，中间省略了一些细节处理的说明，但不得不提的是LeakCanary支持自定义泄漏豁对象ExcludedRefs的集合，这些豁免对象一般都是一些已知的系统泄漏问题或者自己工程中已知但又需要被排除在检查之外的泄漏问题构成的。LeakCanary在findLeakTrace方法中如果发现这个集合中的对象存在于泄漏路径上，就会排除掉这条泄漏路径并尝试寻找下一条。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://LionelCursor.github.io/2016/02/28/LeakCanary原理分析/" data-id="cinuzx9cn000l0kc0zqgm7vcm" class="article-share-link">Cuota</a><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2016/02/29/computer_network/" class="pre">计算机网络知识总结</a><a href="/2016/02/28/zxing-android-client/" class="next">zxing-android-client</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://LionelCursor.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categorías</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Foundation/">Foundation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Etiquetas</i></div><div class="tagcloud"><a href="/tags/Interview/" style="font-size: 15px;">Interview</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Concurrent/" style="font-size: 15px;">Concurrent</a> <a href="/tags/Alg/" style="font-size: 15px;">Alg</a> <a href="/tags/DataStructure/" style="font-size: 15px;">DataStructure</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Quick-Reference/" style="font-size: 15px;">Quick Reference</a> <a href="/tags/Others/" style="font-size: 15px;">Others</a> <a href="/tags/Canvas/" style="font-size: 15px;">Canvas</a> <a href="/tags/Summary/" style="font-size: 15px;">Summary</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/SourceCode/" style="font-size: 15px;">SourceCode</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/OpenSource/" style="font-size: 15px;">OpenSource</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/500L/" style="font-size: 15px;">500L</a> <a href="/tags/aosabook/" style="font-size: 15px;">aosabook</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/alg/" style="font-size: 15px;">alg</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recientes</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/06/译-信号系统分析实践——计步器/">[译]信号系统分析实践——计步器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/用JUnit与Mock框架对Android项目进行单元测试/">用JUnit与Mock框架对Android项目进行单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/19/onCreate方法的一次debug/">onCreate方法的一次debug</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/Logger-in-xUtils/">Logger in xUtils</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/29/computer_network/">计算机网络知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/LeakCanary原理分析/">LeakCanary原理分析 [转载]</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/zxing-android-client/">zxing-android-client</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/RxJava3/">ReactiveX Operator 总结 及其它重要概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/RxJava2/">RxJava原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/22/RxJava/">RxJava基础应用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://github.com/LionelCursor" title="我的github" target="_blank">我的github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Damon Lei.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?06d5a7998bcfa3c5d037974c6aa847fc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>